/* autogenerated by Processing revision 1293 on 2024-10-07 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import ddf.minim.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Tetris extends PApplet {



Minim minim;
boolean canPlaySound = true;

int[][] grid = new int[10][20];
int[] speeds = {48, 43, 38, 33, 28, 23, 18, 13, 8, 6, 5, 5, 5, 4, 4, 4, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1};
int tetrominoType;
int nextTetrominoType;
int blockSize = 28;
int GameState;
int resetIndex;
int gameOverCounter;
int turnCorrection = 1;

PVector[] tetromino = new PVector[4];
PVector[] nextTetromino = new PVector[4];

PFont zigFont;
PImage backgroundImage;
PImage baseImage;

public void settings() {
  blockSize = floor(displayHeight/203)*7;
  size(25*blockSize, 29*blockSize);
}

public void setup() {
  for (int i=0; i<drawConstants.length; i++) {
    drawConstants[i] = turnIntoEven(PApplet.parseInt(drawConstants[i]*blockSize));
  }
  drawConstants[2] = drawConstants[0] - 2*drawConstants[1];

  // Load all sounds used in the game
  loadAllSounds();

  // Load the font style and apply it
  zigFont = createFont("zig.ttf", 90);
  textFont(zigFont);

  baseImage = loadImage("base.png");
  backgroundImage = loadImage("background.png");
  if (backgroundImage == null || backgroundImage.height != height) {
    createBackground();
  }

  // Load the 'highscore' value from memory if it exists
  try {
    highscore = PApplet.parseInt(loadStrings("HIGHSCORE.txt")[0]);
  } 
  catch (NullPointerException e) {
    highscore = 0;
  }
}

public void createBackground() {
  noStroke();
  baseImage.loadPixels();
  float scl = round(blockSize/7);
  for (int x=0; x<baseImage.width; x++) {
    for (int y=0; y<baseImage.height; y++) {
      int index = x + y*baseImage.width;
      int c = baseImage.pixels[index];
      fill(c);
      rect(x*scl, y*scl, scl, scl);
    }
  }
  save("background.png");
  backgroundImage = loadImage("background.png");
}

public float d3(float x1, float y1, float z1, float x2, float y2, float z2) {
  return (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) + (z2-z1)*(z2-z1);
}

public void draw() {
  image(backgroundImage, -1, -1);

  // Display everything in the game
  DisplayBoardAndUI();
  DisplayGrid();
  if (!isPlacingPiece) {
    DisplayTetromino();
  }

  switch(GameState) {

    /*      Main Menu      */
  case 0:
    // Tint the entire screen black
    noStroke();
    fill(0, 200);
    rectMode(CORNER);
    rect(0, 0, width, height);

    // Display the "Press 'Enter'" text
    if (floor(frameCount/30) % 2 == 0) {
      fill(255, 0, 0);
      textSize(0.05f*height);
      textAlign(CENTER);
      text("Select Level (0-19)", width/2, height/2);
    }
    break;



    /*      Playing Game      */
  case 1:
    if (waitStartCounter != 0) {
      waitStartCounter--;
    }

    if (isRemovingLines) {
      if (frameCount % 4 == 0) {
        // If the line removal process is complete,
        // shift everything down and prepare for the next piece
        if (removingIndex < 0) {
          for (Integer j : linesToBeRemoved) {
            dropTheRowsAbove(j);      // Move the grid down
            lineCount ++;             // Count the number of lines removed
            checkLevelDifficulty();   // Check if the line count reaches a new level
          }

          // If the move was a tetris (i.e. 4 lines were removed)
          if (isTetris) {
            // Count the number of tetris lines and reset the burn counter
            tetrisLineCount += 4;
            burnCount = 0;
          } 
          // If the move wasn't a tetris (i.e. 1, 2, or 3 lines were removed)
          else {
            // Add the number of lines removed to the burn counter
            burnCount += linesToBeRemoved.size();
          }

          // Calculate the player's score based on the lines removed
          calculateScore();

          // Reset everything and setup the next piece
          linesToBeRemoved.clear();
          setupNextPiece();
          removingIndex = floor(grid.length/2);
          isRemovingLines = false;
          isTetris = false;
        }

        // Remove every block of the completed rows
        removeLine();
      }
    }

    // If the game should move the tetromino down...
    else {
      // Move the tetromino down based on the current fall rate
      if (isPlacingPiece) {
        // After placement, check for completed lines
        checkLines();

        if (hasCalculatedARE) {
          if (ARE != 0) {
            ARE--;
          } else {
            setupNextPiece();
          }
        }
      } else {
        if (isUsingDAS) {
          if (DAScounter == 0) {
            moveHorizontally(movementDIR);
          } else if (DAScounter > 15) {
            if ((DAScounter-16)%6 == 0) {
              moveHorizontally(movementDIR);
            }
          }
        }
        if (frameCount % calculateCurrentSpeed() == 0) {
          if (waitStartCounter == 0) {
            moveDown();
          }

          // If the player is using soft drop, 
          // increase the score every time the tetromino goes down
          if (isSoftDropping) {
            softDropScore++;
          }
        }
      }
      if (isUsingDAS) {
        DAScounter++;
      }
    }
    break;



    /*      Kill Screen (Game Over)      */
  case 2:
    if (gameOverCounter != 0) {
      gameOverCounter--;
    } else if (frameCount % 5 == 0) {
      // Once the grid is filled, reset the game
      if (resetIndex == grid[0].length) {
        ResetGame();
        return;
      }
      resetIndex++;
    }

    for (int j=0; j<resetIndex; j++) {
      float x = blockSize*8;
      float y = blockSize*(j + 0.5f + 6);
      rectMode(CENTER);
      noStroke();
      fill(0);
      rect(x, y, blockSize*grid.length, blockSize);
      fill(levelColors[0]);
      rect(x, y-blockSize/4, blockSize*grid.length, blockSize/3);
      fill(levelColors[1]);
      rect(x, y+blockSize/4, blockSize*grid.length, blockSize/3);
      fill(255);
      rect(x, y, blockSize*grid.length, blockSize/3);
      for (int i=0; i<10; i++) {
        grid[i][resetIndex-1] = 0;
      }
    }
    break;
  }
}



public void GenerateTetromino() {
  // Create the current tetromino's coordinates
  // (units are indecies |    (x,y) = (i,j)
  switch(tetrominoType) {
  case 1:
    // O block
    tetromino[0] = new PVector(4, 0);
    tetromino[1] = new PVector(4, 1);
    tetromino[2] = new PVector(5, 0);
    tetromino[3] = new PVector(5, 1);
    break;
  case 2:
    // T block
    tetromino[0] = new PVector(5, 0);
    tetromino[1] = new PVector(4, 0);
    tetromino[2] = new PVector(6, 0);
    tetromino[3] = new PVector(5, 1);
    break;
  case 3:
    // L block
    tetromino[0] = new PVector(5, 0);
    tetromino[1] = new PVector(4, 0);
    tetromino[2] = new PVector(4, 1);
    tetromino[3] = new PVector(6, 0);
    break;
  case 4:
    // J block
    tetromino[0] = new PVector(5, 0);
    tetromino[1] = new PVector(4, 0);
    tetromino[2] = new PVector(6, 0);
    tetromino[3] = new PVector(6, 1);
    break;
  case 5:
    // I block
    tetromino[0] = new PVector(5, 0);
    tetromino[1] = new PVector(3, 0);
    tetromino[2] = new PVector(4, 0);
    tetromino[3] = new PVector(6, 0);
    break;
  case 6:
    // S block
    tetromino[0] = new PVector(5, 0);
    tetromino[1] = new PVector(5, 1);
    tetromino[2] = new PVector(4, 1);
    tetromino[3] = new PVector(6, 0);
    break;
  case 7:
    // Z block
    tetromino[0] = new PVector(5, 0);
    tetromino[1] = new PVector(5, 1);
    tetromino[2] = new PVector(4, 0);
    tetromino[3] = new PVector(6, 1);
    break;
  }

  // If the current tetromino is not an I piece, increase the dought count
  if (tetrominoType != 5) {
    droughtCount ++;
  } 
  // If the current tetromino is an I piece, set the drought count to 0
  else {
    droughtCount = 0;
  }


  // If the current tetromino touches another block (i.e. it can not spawn),
  // the game has ended
  for (PVector p : tetromino) {
    if (touchesOtherBlock(PApplet.parseInt(p.x), PApplet.parseInt(p.y))) {
      EndGame();
      return;
    }
  }
}


public void GenerateNextTetromino() {
  // Create the next tetromino's coordinates
  // (units are in block sizes |    1 unit = 1 block size   )
  switch(nextTetrominoType) {
  case 1:
    // O block
    nextTetromino[0] = new PVector(-0.5f, -0.5f);
    nextTetromino[1] = new PVector(-0.5f, 0.5f);
    nextTetromino[2] = new PVector(0.5f, -0.5f);
    nextTetromino[3] = new PVector(0.5f, 0.5f);
    break;
  case 2:
    // T block
    nextTetromino[0] = new PVector(0, -0.5f);
    nextTetromino[1] = new PVector(-1, -0.5f);
    nextTetromino[2] = new PVector(1, -0.5f);
    nextTetromino[3] = new PVector(0, 0.5f);
    break;
  case 3:
    // L block
    nextTetromino[0] = new PVector(0, -0.5f);
    nextTetromino[1] = new PVector(-1, -0.5f);
    nextTetromino[2] = new PVector(-1, 0.5f);
    nextTetromino[3] = new PVector(1, -0.5f);
    break;
  case 4:
    // J block
    nextTetromino[0] = new PVector(0, -0.5f);
    nextTetromino[1] = new PVector(-1, -0.5f);
    nextTetromino[2] = new PVector(1, -0.5f);
    nextTetromino[3] = new PVector(1, 0.5f);
    break;
  case 5:
    // I block
    nextTetromino[0] = new PVector(0.5f, 0);
    nextTetromino[1] = new PVector(-1.5f, 0);
    nextTetromino[2] = new PVector(-0.5f, 0);
    nextTetromino[3] = new PVector(1.5f, 0);
    break;
  case 6:
    // S block
    nextTetromino[0] = new PVector(0, -0.5f);
    nextTetromino[1] = new PVector(1, -0.5f);
    nextTetromino[2] = new PVector(0, 0.5f);
    nextTetromino[3] = new PVector(-1, 0.5f);
    break;
  case 7:
    // Z block
    nextTetromino[0] = new PVector(0, -0.5f);
    nextTetromino[1] = new PVector(1, 0.5f);
    nextTetromino[2] = new PVector(0, 0.5f);
    nextTetromino[3] = new PVector(-1, -0.5f);
    break;
  }

  // Magnify the coordinates of each block and move it into the display panel
  for (PVector p : nextTetromino) {
    p.mult(blockSize);
    p.add(blockSize*19.5f, blockSize*7.5f);
  }
}

public void StartGame() {
  fallSpeed = speeds[difficultyLevel];
  GameState = 1;
  startLevel = difficultyLevel;
  nextTetrominoType = floor(random(1, 8));
  setupNextPiece();
  for (int i=0; i<grid.length; i++) {
    for (int j=0; j<grid[0].length; j++) {
      grid[i][j] = 0;
    }
  }
  if (canPlaySound)
    startSound.trigger();
  if (difficultyLevel < 10) {
    advanceAmount = difficultyLevel*10 + 10;
  } else {
    advanceAmount = max(100, (difficultyLevel*10)-50);
  }

  levelColors = getCurrentLevelColors();
}

public void ResetGame() {
  // Reset all values
  GameState = 0;
  resetIndex = 0;
  if (score > highscore) {
    highscore = score;
    String[] s = {str(highscore)};
    saveStrings("HIGHSCORE.txt", s);
  }
  score = 0;
  softDropScore = 0;
  lineCount = 0;
  tetrisLineCount = 0;
  difficultyLevel = 0;
  burnCount = 0;
  droughtTextRedValue = 255;
  droughtCount = 0;
  fallSpeed = 30;
  waitStartCounter = 80;
}

public int turnIntoEven(int n) {
  if (n % 2 != 0) {
    return n+1;
  }
  return n;
}
int removingIndex = floor(grid.length/2);
boolean isRemovingLines;
boolean isTetris;
ArrayList<Integer> linesToBeRemoved = new ArrayList<Integer>();


public void checkLines() {
  if (hasCalculatedARE) {
    return;
  }
  // Check each row and see if it is completed
  for (int j=0; j<grid[0].length; j++) {
    int total = 0;
    for (int i=0; i<grid.length; i++) {
      if (grid[i][j] > 0) {
        total++;
      }
    }

    // If the row is completed, add it to the "linesToBeRemoved" list
    if (total == grid.length) {
      linesToBeRemoved.add(j);
    }
  }


  // If there are no lines to be removed...
  if (linesToBeRemoved.isEmpty()) {
    // Calculate the ARE (the number of frames we wait before the next piece comes in)
    // Find the row the tetromino is placed
    float maxY = 0;
    for (PVector p : tetromino) {
      maxY = max(p.y, maxY);
    }

    // Calculate the ARE based on the row
    ARE = 10 + floor((21-maxY)/4)*2;
    hasCalculatedARE = true;
    if (canPlaySound)
      placeTetrominoSound.trigger();
  } 
  // If we have lines to remove...
  else {
    isRemovingLines = true;

    // If the number of lines removed is 4, the move is a tetris
    if (linesToBeRemoved.size() == 4) {
      isTetris = true;
      if (canPlaySound)
        tetrisClearSound.trigger();
    } 
    // If not, then its just a normal line clear
    else {
      if (canPlaySound)
        lineClearSound.trigger();
    }
  }
}

public void setupNextPiece() {
  // Set the type of the current and next tetromino
  tetrominoType = nextTetrominoType;
  nextTetrominoType = floor(random(1, 8));

  // Create the current and next tetromino
  GenerateNextTetromino();
  GenerateTetromino();

  // Give points to the player based on how long they have soft dropped
  score += softDropScore;

  // Reset the soft drop score
  softDropScore = 0;

  // Reset variables for next piece
  isPlacingPiece = false;
  hasCalculatedARE = false;
  turnCorrection = 1;

  // Save the current score if its greater than the highscore.
  // We do it here so that if the game quits accidentally, the score is saved
  if (score > highscore) {
    String[] s = {str(highscore)};
    saveStrings("HIGHSCORE.txt", s);
  }
}


public void removeLine() {
  // Every few frames, remove a block from the completed rows
  for (Integer j : linesToBeRemoved) {
    grid[removingIndex][j] = 0;
    grid[grid.length-1-removingIndex][j] = 0;
  }
  removingIndex--;
}

public void dropTheRowsAbove(int bottom) {
  // Move all the blocks above the given row down
  for (int j=bottom; j>=0; j--) {
    for (int i=0; i<grid.length; i++) {
      if (j == 0) {
        grid[i][j] = 0;
      } else {
        grid[i][j] = grid[i][j-1];
      }
    }
  }
}
int[] levelColors = new int[2];

public void DisplayGrid() {
  if (isTetris) {
    // Flashing black and white background during a Tetris
    if (floor(frameCount/4) % 2 == 0) {
      fill(255);
    } else {
      fill(0);
    }
  } else {
    // Regular black background
    fill(0);
  }
  // Display the background of the board
  rectMode(CORNER);
  noStroke();
  rect(blockSize*3, blockSize*6, grid.length*blockSize, grid[0].length*blockSize);

  // Display all the elements in the grid[][] array
  for (int i=0; i<grid.length; i++) {
    for (int j=0; j<grid[0].length; j++) {
      int value = grid[i][j];
      float x = blockSize*(3 + i + 0.5f);
      float y = blockSize*(6 + j + 0.5f);
      if (value > 0) {
        DisplayBlock(x, y, value);
      }
    }
  }
}

public void DisplayTetromino() {
  for (PVector p : tetromino) {
    if (p == null) 
      break;
    float x = blockSize*(3 + p.x + 0.5f);
    float y = blockSize*(6 + p.y + 0.5f);
    if (y < blockSize*6) {
      continue;
    }
    // Display the block based on its type
    DisplayBlock(x, y, tetrominoType);
  }
}

public void DisplayBoardAndUI() {
  /*     UI elements     */

  // Score
  fill(255);
  textSize(0.04f*height);
  textAlign(CENTER);
  text("SCORE", blockSize*3 + (grid.length/2*blockSize), blockSize*3);
  textSize(0.06f*height);
  text(score, blockSize*3 + PApplet.parseInt(grid.length/2*blockSize), blockSize*4.5f);

  // Highscore
  textSize(0.03f*height);
  text("HIGHSCORE", blockSize*19.5f, blockSize*3);
  textSize(0.04f*height);
  text(highscore, blockSize*19.5f, blockSize*4.5f);

  // Next tetromino
  for (PVector p : nextTetromino) {
    if (p == null) 
      break;
    DisplayBlock(p.x, p.y, nextTetrominoType);
  }

  // Line count
  textSize(0.03f*height);
  text("LINE", blockSize*19.5f, blockSize*11);

  // Level count
  text("LV", blockSize*19.5f, blockSize*15);

  // Tetris rate count
  text("TRT", blockSize*19.5f, blockSize*19);
  int percentage = 0;
  if (lineCount != 0) {
    percentage = PApplet.parseInt(PApplet.parseFloat(tetrisLineCount)/PApplet.parseFloat(lineCount) * 100);
  }

  // Burn count - Drought count

  // If the drought count is above 13, display a pulsing red drought counter
  if (droughtCount > 12) {
    // Display a flashing I piece
    noStroke();
    rectMode(CORNER);
    for (int i=0; i<4; i++) {
      float x = blockSize*(18+i);

      // I piece
      fill(levelColors[1], droughtTextRedValue);
      rect(x-drawConstants[3], blockSize*22.2f, drawConstants[0], drawConstants[0]);

      // White parts
      fill(droughtTextRedValue);
      rect(x-drawConstants[3]+drawConstants[1], blockSize*22.2f+drawConstants[1], drawConstants[2], drawConstants[2]);
      rect(x-drawConstants[3], blockSize*22.2f, drawConstants[1], drawConstants[1]);

      // Red tint
      fill(droughtTextRedValue, 0, 0, 100);
      rect(x-drawConstants[3], blockSize*22.2f, drawConstants[0], drawConstants[0]);
    }

    // Display the drought counter
    fill(255, 0, 0, droughtTextRedValue);
    textSize(0.055f*height);
    text(droughtCount, blockSize*19.5f, blockSize*24.5f);

    // Update the fade value
    droughtTextRedValue-=5;
    if (droughtTextRedValue <= 0) {
      droughtTextRedValue = 255;
    }
  } 

  // If the drought counter should not be displayed, show the burn counter instead
  else {
    fill(255);
    text("BRN", blockSize*19.5f, blockSize*23);
    textSize(0.05f*height);
    text(burnCount, blockSize*19.5f, blockSize*24.5f);
  }

  fill(255);
  textSize(0.05f*height);
  text(lineCount, blockSize*19.5f, blockSize*12.5f);
  text(difficultyLevel, blockSize*19.5f, blockSize*16.5f);
  text(percentage + "%", blockSize*19.5f, blockSize*20.5f);
}

public int[] getCurrentLevelColors() {
  int[] output = new int[2];
  switch((difficultyLevel-startLevel)%10) {
  case 0:
    output[0] = color(160, 30, 30);
    output[1] = color(60, 50, 240);
    break;
  case 1:
    output[0] = color(220, 150, 35);
    output[1] = color(160, 30, 30);
    break;
  case 2:
    output[0] = color(95, 170, 350);
    output[1] = color(60, 50, 240);
    break;
  case 3:
    output[0] = color(135, 235, 15);
    output[1] = color(25, 165, 10);
    break;
  case 4:
    output[0] = color(220, 75, 250);
    output[1] = color(135, 5, 190);
    break;
  case 5:
    output[0] = color(90, 255, 80);
    output[1] = color(60, 50, 245);
    break;
  case 6:
    output[0] = color(70, 240, 120);
    output[1] = color(160, 10, 110);
    break;
  case 7:
    output[0] = color(140, 130, 250);
    output[1] = color(70, 245, 125);
    break;
  case 8:
    output[0] = color(90);
    output[1] = color(160, 35, 30);
    break;
  case 9:
    output[0] = color(85, 0, 55);
    output[1] = color(100, 20, 250);
    break;
  }
  return output;
}

float[] drawConstants = {0.857f, 0.143f, 0, 0.45f};

public void DisplayBlock(float x_, float y_, int type) {
  int x = PApplet.parseInt(x_);
  int y = PApplet.parseInt(y_);
  int textureType = -1;
  switch(type) {
  case 1: 
  case 2: 
  case 5:
    textureType = 0;
    break;
  case 4: 
  case 6: 
    textureType = 1;
    break;
  case 3: 
  case 7: 
    textureType = 2;
    break;
  }
  //println(blockSize);

  noStroke();
  rectMode(CORNER);

  // The color of the block based on the level
  if (textureType == 2) {
    fill(levelColors[0]);
  } else {
    fill(levelColors[1]);
  }
  rect(x-drawConstants[3], y-drawConstants[3], drawConstants[0], drawConstants[0]);

  // The white parts of the block
  fill(255);
  rect(x-drawConstants[3], y-drawConstants[3], drawConstants[1], drawConstants[1]);
  if (textureType == 0) {
    rect(x-drawConstants[3]+ drawConstants[1], y-drawConstants[3]+ drawConstants[1], drawConstants[2], drawConstants[2]);
  } else {
    rect(x-drawConstants[3] + drawConstants[1], y-drawConstants[3] + drawConstants[1], drawConstants[1], drawConstants[1]);
    rect(x-drawConstants[3] + drawConstants[1]*2, y-drawConstants[3] + drawConstants[1], drawConstants[1], drawConstants[1]);
    rect(x-drawConstants[3] + drawConstants[1], y-drawConstants[3] + drawConstants[1]*2, drawConstants[1], drawConstants[1]);
  }
}
int fallSpeed = speeds[0];
boolean isSoftDropping;
int waitStartCounter = 80;
float ARE;
boolean isPlacingPiece;
boolean hasCalculatedARE;
boolean isUsingDAS;
int DAScounter;
int movementDIR;

public void moveDown() {
  // Don't move down if the tetromino touches the floor or another block,
  // place it instead
  for (PVector p : tetromino) {
    if (p == null) 
      return;
    if (touchesFloor(PApplet.parseInt(p.y + 1)) || touchesOtherBlock(PApplet.parseInt(p.x), PApplet.parseInt(p.y+1))) {
      placeTetromino();
      return;
    }
  }

  // If the tetromino can move down, move all of its blocks down
  for (PVector p : tetromino) {
    p.y++;
  }
}

public void moveHorizontally(int direction) {
  // Don't move horizontally if the tetromino touches the walls or another block,
  for (PVector p : tetromino) {
    if (touchesWall(PApplet.parseInt(p.x + direction), direction) || touchesOtherBlock(PApplet.parseInt(p.x+direction), PApplet.parseInt(p.y))) {
      return;
    }
  }

  // If the tetromino can move horizontally, move all of its blocks in the given direction
  if (canPlaySound)
    moveSound.trigger();
  for (PVector p : tetromino) {
    p.x += direction;
  }
}

public void rotateTetromino(int direction) {
  // If the tetromino is an "O" piece, there is no need for rotation so leave the function
  if (tetrominoType == 1) {
    return;
  }

  // Create a temporary tetromino to test if the real one can actually rotate
  PVector[] newTetromino = new PVector[4];
  for (int i=0; i<4; i++) {
    newTetromino[i] = tetromino[i].copy();
  }

  if (tetrominoType == 5) {
    direction = turnCorrection;
  } else if(tetrominoType > 5) {
    direction = -turnCorrection;
  }

  // Get the center of the real tetromino
  PVector center = tetromino[0];
  for (int i=1; i<4; i++) {
    // Loop through every other block and rotate it based on the given direction
    PVector oldP = tetromino[i];
    float xOff = oldP.x - center.x;
    float yOff = oldP.y - center.y;
    float newX = center.x - yOff * direction;
    float newY = center.y + xOff * direction;

    // If the new rotated position of the block is outside of the grid or touches another block,
    // quit rotating
    if (newX < 0 || newX > grid.length-1 || touchesOtherBlock(PApplet.parseInt(newX), PApplet.parseInt(newY))) {
      return;
    }

    // Set the temporary tetromino's position
    newTetromino[i].set(newX, newY);
  }

  // At this point, we know that the real tetromino can rotate
  // so set its position to the temporary tetromino's position
  if (canPlaySound)
    rotateSound.trigger();
  for (int i=0; i<4; i++) {
    tetromino[i] = newTetromino[i].copy();
  }

  turnCorrection *= -1;
}


// Return true if the given element in the grid is a block
public boolean touchesOtherBlock(int i, int j) {
  if (j < 0)
    return false;
  return grid[i][j] > 0;
}

// Return true if the given row is the bottom most row
public boolean touchesFloor(int j) {
  return j > grid[0].length-1;
} 

// Return true if the given column is outside of the grid's boundaries
public boolean touchesWall(int i, int side) {
  if (side == -1) {
    return i < 0;
  } else if (side == 1) {
    return i > grid.length-1;
  }
  return false;
}

// Calculate the current fall speed of the tetromino
public int calculateCurrentSpeed() {
  int currentSpeed = fallSpeed;
  if (isSoftDropping) {
    currentSpeed = 2;
  }
  return currentSpeed;
}


public void placeTetromino() {
  // Place every block of the tetromino into the grid
  for (PVector p : tetromino) {
    // If the block is about to be placed outside of the grid,
    // the player has lost so end the game
    if (p.y < 0) {
      EndGame();
      return;
    }
    grid[PApplet.parseInt(p.x)][PApplet.parseInt(p.y)] = tetrominoType;
  }
  isPlacingPiece = true;
}
int lineCount;
int tetrisLineCount;
int droughtCount;
int droughtTextRedValue;
int burnCount;
int score;
int highscore;
int softDropScore;
int advanceAmount;
int difficultyLevel;
int startLevel;

public void moveToNextLevel() {
  // Increase the difficulty level and decrease the fall speed of the tetromino
  difficultyLevel++;
  if (canPlaySound)
    levelUpSound.trigger();

  fallSpeed = speeds[constrain(difficultyLevel, 0, 29)];
  levelColors = getCurrentLevelColors();
}


public void checkLevelDifficulty() {
  if (lineCount < advanceAmount) {
    return;
  }

  // Move to the next level every 10 line clears
  if (lineCount % 10 == 0) {
    moveToNextLevel();
  }
}


public void calculateScore() {
  // Give points to the player based on the number of lines cleared and the current level
  switch(linesToBeRemoved.size()) {
  case 1:
    score += 40 * (difficultyLevel + 1);
    break;
  case 2:
    score += 100 * (difficultyLevel + 1);
    break;
  case 3:
    score += 300 * (difficultyLevel + 1);
    break;
  case 4:
    score += 1200 * (difficultyLevel + 1);
    break;
  }
}


public void EndGame() {
  // Move to the kill screen and reset both the tetromino and the next tetromino
  GameState = 2;
  for (PVector p : tetromino) {
    if (p.y < 0) {
      continue;
    }
    grid[PApplet.parseInt(p.x)][PApplet.parseInt(p.y)] = tetrominoType;
  }
  if (isSoftDropping) {
    softDropScore--;
  }
  tetromino = new PVector[4];
  nextTetromino = new PVector[4];
  if (canPlaySound)
    gameOverSound.trigger();
  gameOverCounter = 30;
}
AudioSample lineClearSound;
AudioSample tetrisClearSound;
AudioSample moveSound;
AudioSample rotateSound;
AudioSample placeTetrominoSound;
AudioSample startSound;
AudioSample gameOverSound;
AudioSample levelUpSound;


public void loadAllSounds() {
  minim = new Minim(this);
  
  // Load the sounds from the "Sound" file in memory
  lineClearSound = minim.loadSample("Sounds/Line Clear.mp3");
  tetrisClearSound = minim.loadSample("Sounds/Tetris Clear.mp3");
  moveSound = minim.loadSample("Sounds/Move.mp3");
  rotateSound = minim.loadSample("Sounds/Rotate.mp3");
  placeTetrominoSound = minim.loadSample("Sounds/Place.mp3");
  startSound = minim.loadSample("Sounds/Start.mp3");
  gameOverSound = minim.loadSample("Sounds/Game Over.mp3");
  levelUpSound = minim.loadSample("Sounds/Level Up.mp3");
  rotateSound.setVolume(0.6f);
}
public void keyPressed() {
  // If the user presses 'ENTER' in the main menu, start the game
  if (GameState == 0) {
    if (PApplet.parseInt(key) >= 48 && PApplet.parseInt(key) <= 57) {
      difficultyLevel = PApplet.parseInt(key) - 48;
      StartGame();
    } else {
      switch(key) {
      case ')':
        difficultyLevel = 10;
        break;
      case '!':
        difficultyLevel = 11;
        break;
      case '@':
        difficultyLevel = 12;
        break;
      case '#':
        difficultyLevel = 13;
        break;
      case '$':
        difficultyLevel = 14;
        break;
      case '%':
        difficultyLevel = 15;
        break;
      case '^':
        difficultyLevel = 16;
        break;
      case '&':
        difficultyLevel = 17;
        break;
      case '*':
        difficultyLevel = 18;
        break;
      case '(':
        difficultyLevel = 19;
        break;
      }
      if (difficultyLevel > 9) {
        StartGame();
      }
    }
  } 


  // If the game is currently being played
  else if (GameState == 1) {
    // Move the tetromino based on the arrow keys
    switch(keyCode) {
    case LEFT: 
      isUsingDAS = true;
      movementDIR = -1;
      break;
    case RIGHT: 
      isUsingDAS = true;
      movementDIR = 1;
      break;
    case DOWN: 
      if (!isPlacingPiece && waitStartCounter == 0)
        isSoftDropping = true;
      break;
    }

    // Rotate the tetromino based on the letter keys
    if (!isPlacingPiece) {
      switch(key) {
      case 'a': 
      case 'A':
        rotateTetromino(-1);
        break;
      case 'd': 
      case 'D':
        rotateTetromino(1);
        break;
      }
    }
  }

  if (key == 'm') {
    canPlaySound = !canPlaySound;
  }

  if (key == '[') {
    blockSize -= 7;
    surface.setSize(blockSize*25, blockSize*29);
    createBackground();
  } else if (key == ']') {
    blockSize += 7;
    surface.setSize(blockSize*25, blockSize*29);
    createBackground();
  }
}

public void keyReleased() {
  // Once the user has released the DOWN arrow, stop soft dropping
  switch(keyCode) {
  case DOWN: 
    isSoftDropping = false;
    softDropScore = 0;
    break;
  case LEFT: 
  case RIGHT:
    isUsingDAS = false;
    DAScounter = 0;
    break;
  }
}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Tetris" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
